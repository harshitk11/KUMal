"""
Python module to get categorize the benigns and the malware apks:
- Find the category of the benign apks
- Find the malware family of the malware apks using Euphony
"""

import argparse
import os
import json
import urllib.request
import re
import collections

class utils:
    """
    Contains all the helper methods for this script.
    """
    @staticmethod
    def generate_hash_package(meta_info_path):
        """
        Generates list of packages from the meta-info files 
            (generated by download_apk.py in /baremetal_collection_framework/download_apk.py)
        
        params:
            - meta_info_path: List of meta-info files (with path) for which the list of package names needs to be generated
        
        Output:
            - dict_hash_package_name : Hashtable with key=hash and value=package name
        """
        dict_hash_package_name = {}

        with open(meta_info_path) as f:
            data = json.load(f)

        for hash, minfo in data.items():
            dict_hash_package_name[hash] = minfo[5]
        
        return dict_hash_package_name


def categorize_malware_apks():
    """
    Python module to find the fmaily of malware applications.
    """
    pass

class benign_apk_categorization:

    def __init__(self, args) -> None:
        # args
        self.args = args

        # Create the folder to store the summary stats
        summary_stat_savepathfolder = os.path.join(self.args.xmd_base_folder,"res","category_benign_malware_apk")
        if not os.path.isdir(summary_stat_savepathfolder):
            os.system(f"mkdir -p {summary_stat_savepathfolder}")
        
        # Summary stat file name with path
        self.summaryStatFName = os.path.join(summary_stat_savepathfolder, "benign_category_stats.json")
        
    @staticmethod
    def benign_apk_category(hash_package_name):
        """
        Given a list of package names, it will return the list of corresponding category found on Google Play Store.
        params:
            - hash_package_name : Hash table with key = SHA256 and value = package name
        Output:
            - hash_category : Hash table with key = SHA256 and value = category
                                category = None if no category found (i.e. the apk is no longer hosted on Google PlayStore)
        """
        # Output
        hash_category = {}
        
        # To track the number of packages for which category could not be extracted
        fileNotFoundCounter = 0
        
        for hash,pname in hash_package_name.items():
            try:
                # Get the html file
                with urllib.request.urlopen(f'https://play.google.com/store/apps/details?id={pname}&hl=en') as response:
                    html = response.read()

                # Parse the html file to get the apk category
                try:
                    links = re.findall(b'\"applicationCategory\":\"(\w*)\"', html)
                    if links:
                        hash_category[hash] = links[0].decode()
                        
                # Application category not found
                except:
                    fileNotFoundCounter += 1
                    hash_category[hash] = None
                    print(f" - Application Category not found | Counter : {fileNotFoundCounter}")

            except:
                fileNotFoundCounter += 1
                hash_category[hash] = None
                print(f" - File not found | Counter : {fileNotFoundCounter}")
            
            print(hash, hash_category[hash])

        return hash_category

    @staticmethod
    def get_summary_stats(hash_category):
        """
        Returns the summary of all the categories with the corresponding number of applications in the dataset.
        
        params:
            - hash_category : Hash table with key = hash and value = category
        
        Output:
            - category_stat : Hash table with key = category and value = # of apk in that category
        """
        category_stat = {}

        for _, category in hash_category.items():
            if category in category_stat:
                category_stat[category] += 1
            else:
                category_stat[category] = 0

        # Sort category stat wrt the category name
        category_stat = dict(sorted(category_stat.items()))

        print(f" -------------- Summary statistics of category -------------- ")
        for category,num_apk in category_stat.items():
            print(f"{category}: {num_apk}")

        return category_stat

    def categorize_benign_apks(self):
        """
        Python module to find the category of benign applications. Writes the summary stats containing the category
        and the corresponding number of apk for that category in a json file.

        Output: 
            - summary_stat_dict = {key = dataset_name, value = summary_stats}
        """
        summary_stat_dict = {}

        # Paths where the meta-info files are stored
        benign_apk_paths = {
            "std_benign":os.path.join(self.args.xmd_base_folder,"baremetal_data_collection_framework","androzoo","metainfo","meta_info_std_benign.json"),
            "cd_year1_benign":os.path.join(self.args.xmd_base_folder,"baremetal_data_collection_framework","androzoo","metainfo","meta_info_cd_year1_benign.json"),
            "cd_year2_benign":os.path.join(self.args.xmd_base_folder,"baremetal_data_collection_framework","androzoo","metainfo","meta_info_cd_year2_benign.json"),
            "cd_year3_benign":os.path.join(self.args.xmd_base_folder,"baremetal_data_collection_framework","androzoo","metainfo","meta_info_cd_year3_benign.json"),
                            }
        

        for dataset_name, metainfo_path in benign_apk_paths.items():
            # Get the hash table containing the hash and the package name
            hash_package_name = utils.generate_hash_package(meta_info_path = metainfo_path) 
            
            # Get the category
            hashCategory = benign_apk_categorization.benign_apk_category(hash_package_name=hash_package_name)

            # Get the summary statistics
            category_stat = benign_apk_categorization.get_summary_stats(hash_category = hashCategory)
            summary_stat_dict[dataset_name] = category_stat

        # Write the dict to a file
        with open(self.summaryStatFName, 'w') as f:
            json.dump(summary_stat_dict, f, indent=4)

        return summary_stat_dict
        

    def get_summary_stats_all_datasets(self):
        """
        If the summary stats have already been generated, then will load the file.
        Else will generate the summary stats for all the datasets.

        Output:
            - summary_stat_dict : {
                <dataset-name> : {<category> : # of apks, ...},
                                ... 
            }
        """
        if os.path.isfile(self.summaryStatFName):
            # Load the previously generated summary stats
            with open(self.summaryStatFName,'r') as f:
                return json.load(f)
        else:
            # Generate new summary stats and return it
            return self.categorize_benign_apks()


def main():
    # Location of the base folder of xmd 
    dir_path = os.path.dirname(os.path.realpath(__file__))
    base_folder_location = os.path.join(dir_path.replace("/src",""),"")
    
    # Setting up the parser
    parser = argparse.ArgumentParser(description="XMD : Late-stage fusion.")
    parser.add_argument('--categorize_benign','-cb',  dest='categorize_benign', action='store_true', help = 'Categorize the benign apks.')
    parser.add_argument('--categorize_malware','-cm', dest='categorize_malware', action='store_true', help = 'Categorize the malware apks.')
    args = parser.parse_args()
    args.xmd_base_folder = base_folder_location
    
    # Perform the benign and malware family categorization
    if args.categorize_benign:
        bkCat = benign_apk_categorization(args=args)
        bkCat.get_summary_stats_all_datasets()

    elif args.categorize_malware:
        categorize_malware_apks(args=args)

    else:
        raise ValueError("Pass --categorize_malware (-cm) or --categorize_benign (-cb) to categorize the corresponding apks.")

if __name__ == '__main__':
    main()